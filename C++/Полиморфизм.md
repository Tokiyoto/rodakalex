Полиморфизм — один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет объектам разных классов обрабатывать вызовы методов общего интерфейса разными способами. Полиморфизм позволяет использовать единый интерфейс для работы с объектами различных типов и адаптировать поведение этих объектов в зависимости от их конкретного типа.

В C++ полиморфизм реализуется двумя основными способами:

1. **Полиморфизм времени выполнения (динамический полиморфизм)**:
   - Основан на использовании виртуальных функций и наследования.
   - Позволяет объектам производных классов заменять реализацию методов базового класса, обеспечивая возможность вызова правильной версии метода в зависимости от типа объекта.

   Пример:

   ```cpp
   #include <iostream>
   
   class Base {
   public:
       virtual void speak() const { std::cout << "Base class\n"; } // Виртуальная функция
       virtual ~Base() = default; // Виртуальный деструктор
   };

   class Derived : public Base {
   public:
       void speak() const override { std::cout << "Derived class\n"; } // Переопределение виртуальной функции
   };

   void makeSpeak(const Base& obj) {
       obj.speak(); // Вызов виртуальной функции
   }

   int main() {
       Base base;
       Derived derived;
       
       makeSpeak(base);     // Вывод: Base class
       makeSpeak(derived);  // Вывод: Derived class

       return 0;
   }
   ```

   В этом примере функция `speak()` определена как виртуальная в базовом классе `Base`. Это позволяет производному классу `Derived` переопределить эту функцию и предоставить собственную реализацию. При вызове `makeSpeak()` правильная версия функции `speak()` вызывается в зависимости от типа объекта, переданного в функцию.

2. **Полиморфизм времени компиляции (статический полиморфизм)**:
   - Достигается через функции шаблонов и перегрузку функций. Позволяет компилятору выбирать подходящую версию функции или оператора на основе типов аргументов во время компиляции.

   Пример:

   ```cpp
   #include <iostream>
   
   // Функция шаблона
   template <typename T>
   void print(T value) {
       std::cout << "Value: " << value << std::endl;
   }

   // Перегрузка функции
   void print(int value) {
       std::cout << "Integer: " << value << std::endl;
   }

   int main() {
       print(10);       // Вывод: Integer: 10
       print(10.5);     // Вывод: Value: 10.5
       print("Hello"); // Вывод: Value: Hello

       return 0;
   }
   ```

   В этом примере функция `print` перегружена для работы с различными типами данных. Функция шаблона позволяет работать с любыми типами, а перегруженная функция обрабатывает целые числа.

### Ключевые концепции полиморфизма

1. **Виртуальные функции**:
   - Используются для реализации динамического полиморфизма. Виртуальная функция объявляется в базовом классе и переопределяется в производном классе. Когда функция вызывается через указатель или ссылку на базовый класс, вызывается версия функции, соответствующая типу объекта, на который указывает указатель или ссылка.

2. **Чисто виртуальные функции**:
   - Функции, которые не имеют реализации в базовом классе и должны быть переопределены в производных классах. Класс, содержащий чисто виртуальные функции, становится абстрактным классом и не может быть инстанцирован напрямую.

   Пример:
   ```cpp
   class AbstractBase {
   public:
       virtual void pureVirtualFunction() = 0; // Чисто виртуальная функция
   };

   class ConcreteDerived : public AbstractBase {
   public:
       void pureVirtualFunction() override {
           std::cout << "Concrete implementation\n";
       }
   };
   ```

3. **Динамическое разрешение вызовов**:
   - В случае виртуальных функций вызов метода разрешается в зависимости от типа объекта, на который указывает указатель или ссылка, а не от типа переменной, которая используется для хранения указателя или ссылки.

### Преимущества полиморфизма

- **Гибкость и расширяемость**: Можно добавлять новые классы и методы без изменения существующего кода, что упрощает расширение функциональности.
- **Переиспользование кода**: Позволяет писать универсальный код, который работает с объектами разных типов, обеспечивая возможность повторного использования и упрощая сопровождение.

### Заключение

Полиморфизм в C++ позволяет создавать гибкие и расширяемые системы, обеспечивая единый интерфейс для различных типов объектов и позволяя этим объектам выполнять действия по-своему. Он помогает в написании более общих и гибких программ, улучшая читаемость и поддерживаемость кода.

[[C++]]
[[ООП]]