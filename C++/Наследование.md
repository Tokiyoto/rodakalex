Наследование в [[C++]] — это один из ключевых механизмов [[ООП|объектно-ориентированного программирования|]], который позволяет создавать новые классы на основе существующих. Это позволяет организовывать иерархию классов, повторно использовать код и создавать более специализированные версии классов.

Основные моменты, которые нужно знать о наследовании в C++:

1. **Базовый и производный классы**:
   - **Базовый класс** — это класс, от которого наследуются другие классы. Он может содержать общие данные и методы, которые будут использоваться в производных классах.
   - **Производный класс** — это класс, который наследует свойства и методы базового класса и может добавлять свои собственные свойства и методы.

2. **[[Модификаторы доступа в C++|Типы наследования]]**:
   - **Публичное наследование** (`public`): члены базового класса становятся публичными (или защищёнными) в производном классе. Это наиболее часто используемый тип наследования.
   - **Защищённое наследование** (`protected`): члены базового класса становятся защищёнными в производном классе. Это означает, что они будут доступны только в производном классе и его производных, но не вне их.
   - **Приватное наследование** (`private`): члены базового класса становятся приватными в производном классе. Это означает, что они недоступны за пределами производного класса.

3. **Конструкторы и деструкторы**:
   - Конструкторы и деструкторы базового класса вызываются автоматически при создании и уничтожении объектов производного класса. Конструкторы базового класса вызываются сначала, а деструкторы — в обратном порядке.

4. **[[Полиморфизм|Переопределение методов]]**:
   - Метод базового класса может быть переопределён в производном классе. Это позволяет производному классу изменять или расширять поведение, унаследованное от базового класса.

5. **Виртуальные методы и [[полиморфизм]]**:
   - Если метод базового класса объявлен как `virtual`, производный класс может переопределить его, и вызов этого метода будет происходить в соответствии с типом объекта, а не указателя или ссылки на него. Это позволяет реализовать полиморфизм, где поведение метода зависит от типа объекта, на который указывает указатель или ссылка.

Пример кода для иллюстрации наследования:

```cpp
#include <iostream>
using namespace std;

// Базовый класс
class Animal {
public:
    // Конструктор базового класса
    Animal() { cout << "Animal constructor" << endl; }
    
    // Виртуальный метод
    virtual void speak() const { cout << "Animal speaks" << endl; }
    
    // Деструктор базового класса
    virtual ~Animal() { cout << "Animal destructor" << endl; }
};

// Производный класс
class Dog : public Animal {
public:
    // Конструктор производного класса
    Dog() { cout << "Dog constructor" << endl; }
    
    // Переопределение метода
    void speak() const override { cout << "Dog barks" << endl; }
    
    // Деструктор производного класса
    ~Dog() { cout << "Dog destructor" << endl; }
};

int main() {
    Animal* animal = new Dog();
    animal->speak(); // Вызов метода через указатель на базовый класс
    delete animal; // Корректное уничтожение объекта
    return 0;
}
```

В этом примере `Dog` наследует от `Animal`. Когда мы создаём объект `Dog` через указатель типа `Animal`, метод `speak()` будет вызываться для объекта типа `Dog` благодаря виртуальной функции, обеспечивая полиморфизм.