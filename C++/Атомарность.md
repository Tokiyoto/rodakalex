Создадим три потока, которые будут инкрементировать одну и ту же переменную, и покажем, как отсутствие синхронизации может привести к ошибкам.

### Шаг 1: Пример кода без атомарных операций

В этом примере создадим три потока, которые будут инкрементировать переменную `counter` без использования атомарных операций или синхронизации:

```cpp
#include <iostream>
#include <thread>
#include <vector>

volatile int counter = 0; // глобальная переменная

void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // инкрементируем без синхронизации
    }
}

int main() {
    std::vector<std::thread> threads;

    // Запускаем 3 потока
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(increment);
    }

    // Ждем завершения потоков
    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Final counter value: " << counter << std::endl; // Ожидаем 300000
    return 0;
}
```

### Шаг 2: Проблема

Запустив этот код, вы сможете заметить, что значение `counter` в итоге будет меньше ожидаемого (300000). Это происходит из-за того, что операции инкремента не являются атомарными — они разбиваются на несколько шагов (чтение значения, инкремент, запись обратно), и другие потоки могут вмешаться в этот процесс.

### Шаг 3: Решение проблемы с помощью атомарных операций

Теперь давайте исправим код, используя атомарные операции из библиотеки `<atomic>`

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<int> counter(0); // атомарная переменная

void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // атомарный инкремент
    }
}

int main() {
    std::vector<std::thread> threads;

    // Запускаем 3 потока
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(increment);
    }

    // Ждем завершения потоков
    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Final counter value: " << counter.load() << std::endl; // Теперь должно быть 300000
    return 0;
}
```

### Пояснение:

1. **Использование `std::atomic<int>`**: Мы объявляем переменную `counter` как атомарную. Это гарантирует, что операции с этой переменной будут атомарными, т.е. они не будут прерваны на полпути другими потоками.

2. **Использование `counter++`**: Операция инкремента теперь является безопасной в многопоточной среде, и мы можем ожидать, что итоговое значение `counter` будет `300000`.

Таким образом, используя атомарные операции, мы можем решить проблему гонок между потоками и гарантировать корректное поведение программы.